import { instances } from '../logging.js';

const roundToDefault = 100;
export const bytesToClosestUnit = (bytes: number, roundTo = roundToDefault) => {
  const unitDivisor = 1_000;
  const units = ['B', 'KB', 'MB', 'GB'] as const;
  // eslint-disable-next-line functional/no-let
  let value = bytes * roundTo;
  // eslint-disable-next-line functional/no-let
  let unit = 0;
  const limit = unitDivisor * roundTo - 1;
  // eslint-disable-next-line functional/no-loop-statement
  for (; value > limit; value /= unitDivisor) {
    unit += 1;
  }
  const rounded = Math.round(value) / roundTo;
  return { unit: units[unit]!, value: rounded };
};

/**
 * Format bytes into a more human-readable format.
 * Renders results as `B`, `KB`, `MB`, or `GB`, limiting each to
 * `999.99`, e.g.:
 * - `999 B` → `1.00 KB`
 * - `999.99 KB` → `1.00 MB`
 * - `999.99 MB` → `1.00 GB`
 * @param totalBytes - the sum of bytes measured
 * @param totalMs - the sum of milliseconds measured
 */
export const formatBytes = (bytes: number) => {
  const { unit, value } = bytesToClosestUnit(bytes);
  const decimalPlaces = 2;
  return `${unit === 'B' ? value : value.toFixed(decimalPlaces)} ${unit}`;
};

/**
 * Format bytes-per-milliseconds into a more human-readable format.
 * Renders results as `B/s`, `KB/s`, `MB/s`, or `GB/s`, limiting each to
 * `999.99`, e.g.:
 * - `999.99 B/s` → `1.00 KB/s`
 * - `999.99 KB/s` → `1.00 MB/s`
 * - `999.99 MB/s` → `1.00 GB/s`
 * @param totalBytes - the sum of bytes measured
 * @param totalMs - the sum of milliseconds measured
 */
export const formatByteThroughput = (totalBytes: number, totalMs: number) => {
  if (totalMs === 0) return `- B/s`;
  const second = 1_000;
  const bytesPerSecond = (totalBytes / totalMs) * second;
  const { unit, value } = bytesToClosestUnit(bytesPerSecond);
  const decimalPlaces = 2;
  return `${unit === 'B' ? value : value.toFixed(decimalPlaces)} ${unit}/s`;
};

const five = 5;
const minutes = 60;
const secondMs = 1000;
const retentionPeriodInMilliseconds = five * minutes * secondMs;

/**
 * A simple data structure to keep track of observed throughput data over the
 * past aggregation period (default: 5 minutes).
 *
 * This is used for 1) tracking the throughput of downloads from each node and
 * 2) tracking throughput to the database.
 *
 * Node throughput information is also used by the `Agent` to estimate and
 * select the fastest available node for downloading each block.
 *
 * Note: the metric `concurrency` is generated by this class and should never be
 * set by consumers.
 */
export class ThroughputStatistics<Metrics extends { [type: string]: number }> {
  /**
   * An object mapping pending keys to `startTime`s of unfinished statistics.
   */
  pendingStatistics = new Map<symbol, number>();

  statistics: {
    metrics: Metrics;
    durationMs: number;
    startTime: number;
  }[] = [];

  retentionPeriod: number;

  createEmptyMetrics: () => Metrics;

  constructor(
    createEmptyMetrics: () => Metrics,
    retentionPeriod = retentionPeriodInMilliseconds
  ) {
    this.retentionPeriod = retentionPeriod;
    this.createEmptyMetrics = createEmptyMetrics;
  }

  addStatistic({
    durationMs,
    metrics,
    startTime,
  }: {
    startTime: number;
    durationMs: number;
    metrics: Metrics;
  }) {
    if (durationMs < 1) {
      instances.logger!.warn(
        { durationMs, metrics, startTime },
        'Statistic duration bug: attempted to add a statistic with a duration less than 1.'
      );
      return;
    }
    this.statistics.push({ durationMs, metrics, startTime });
  }

  /**
   * TODO: keep `startStatistic`/`stopStatistic`?
   */
  startStatistic(startTimestamp: number) {
    const pendingKey = Symbol('');
    this.pendingStatistics.set(pendingKey, startTimestamp);
    return pendingKey;
  }

  stopStatistic(pendingKey: symbol, endTimestamp: number, metrics: Metrics) {
    const startTime = this.pendingStatistics.get(pendingKey)!;
    this.pendingStatistics.delete(pendingKey);
    const durationMs = endTimestamp - startTime;
    this.addStatistic({ durationMs, metrics, startTime });
  }

  /**
   * Discard all statistics which have fully "aged-out" of the observation
   * window. (The full duration of the statistic is outside of the retention
   * period.)
   */
  discardOldStatistics(now: number) {
    const retentionCutoffTimestamp = now - retentionPeriodInMilliseconds;
    this.statistics = this.statistics.filter(
      (stat) => stat.startTime + stat.durationMs >= retentionCutoffTimestamp
    );
  }

  /**
   * Given a current timestamp, aggregate all statistics falling withing the
   * retention period, discarding any statistics which no longer need to be
   * retained. Returns a variety of statistics and a full graph of per-second
   * throughput metrics.
   *
   * Note: old statistics are only garbage collected by this method. If
   * `aggregateStatistics` isn't called for a long period of time, a
   * `ThroughputStatistics` instance will require continuously more memory as
   * new statistics are added.
   *
   * @remarks
   * This method must account for overlapping, concurrent statistics: if two
   * different processes are competing for the same type of throughput, the
   * throughput statistics should indicate their combined throughput rate (and a
   * concurrency of 2). For this reason, this method must take into account the
   * time and duration of each statistic.
   *
   * To aggregate statistics, this method constructs a timeline with all
   * available samples. Because statistics are collected as objects with a
   * magnitude, time, and duration, this timeline can be best understood as a
   * stair-like graph: each point represents the beginning of a horizontal line
   * which continues until the next point.
   *
   * Conveniently, the area under this graph is precisely a Riemann sum. This
   * method only returns a single average for the entire set of data, but
   * averages (and percentiles) can be computed for any segment of the
   * timeline by summing its area and dividing by the segment duration.
   */
  aggregateStatistics(now: number) {
    this.discardOldStatistics(now);

    type Composite = Metrics & { concurrency: number };
    const createEmptyComposite = (): Composite => ({
      ...this.createEmptyMetrics(),
      concurrency: 0,
    });
    const timelinePerSecond: { time: number; metrics: Composite }[] = [];
    const pendingDrops: { time: number; metrics: Composite }[] = [];

    /**
     * Increase a given set of metrics by another set of metrics.
     */
    const increaseMetrics = (before: Composite, increaseBy: Composite) => {
      const out: Composite = createEmptyComposite();
      Object.keys(out).forEach((key) => {
        const value = before[key]! + increaseBy[key]!;
        out[key as keyof Composite] = value as Composite[keyof Composite];
      });
      return out;
    };

    /**
     * Decrease a given set of metrics by another set of metrics.
     */
    const decreaseMetrics = (before: Composite, reduceBy: Composite) => {
      const out: Composite = createEmptyComposite();
      Object.keys(out).forEach((key) => {
        const value = before[key]! - reduceBy[key]!;
        out[key as keyof Composite] = value as Composite[keyof Composite];
      });
      return out;
    };

    /**
     * Multiply a given set of metrics by a number.
     */
    const multiplyMetric = (
      before: Composite,
      multiplyBy: number,
      excludeConcurrency = false
    ) => {
      const out: Composite = createEmptyComposite();
      Object.keys(out).forEach((key) => {
        if (excludeConcurrency && key === 'concurrency') {
          out[key as keyof Composite] = before[
            key
          ] as Composite[keyof Composite];
          return;
        }
        const value = before[key]! * multiplyBy;
        out[key as keyof Composite] = value as Composite[keyof Composite];
      });
      return out;
    };

    /**
     * Add any drops to the timeline which occur before `cutoffTime`. If
     * `cutoffTime` is `false`, add all pending drops.
     */
    const attemptToRemovePendingDrops = (cutoffTime: number | false) => {
      const ascendingDrops = pendingDrops.sort((a, b) => a.time - b.time);
      // eslint-disable-next-line functional/no-let
      let [nextDrop] = ascendingDrops;
      // eslint-disable-next-line functional/no-loop-statement
      while (
        nextDrop !== undefined &&
        // eslint-disable-next-line no-unmodified-loop-condition
        (cutoffTime === false || nextDrop.time <= cutoffTime)
      ) {
        ascendingDrops.shift();
        const lastPoint = timelinePerSecond[timelinePerSecond.length - 1];
        const newPoint = {
          metrics: decreaseMetrics(lastPoint!.metrics, nextDrop.metrics),
          time: nextDrop.time,
        };
        if (newPoint.time === lastPoint!.time) {
          timelinePerSecond[timelinePerSecond.length - 1] = newPoint;
        } else {
          timelinePerSecond.push(newPoint);
        }
        [nextDrop] = ascendingDrops;
      }
    };

    // eslint-disable-next-line functional/no-let
    let rawTotals = createEmptyComposite();
    // eslint-disable-next-line functional/no-let
    let sumDuration = 0;
    this.statistics.forEach((statistic) => {
      const { startTime, durationMs } = statistic;
      const metrics: Composite = { ...statistic.metrics, concurrency: 1 };
      const endTime = startTime + durationMs;

      sumDuration += durationMs;
      rawTotals = increaseMetrics(rawTotals, metrics);
      attemptToRemovePendingDrops(startTime);

      const durationsPerSecond = secondMs / durationMs;
      const scaledMetrics = multiplyMetric(metrics, durationsPerSecond, true);

      const currentTimelineIndex = timelinePerSecond.length - 1;
      const lastPoint = timelinePerSecond[currentTimelineIndex] ?? {
        metrics: createEmptyComposite(),
        time: startTime,
      };
      const newPoint = {
        metrics: increaseMetrics(lastPoint.metrics, scaledMetrics),
        time: startTime,
      };
      if (newPoint.time === lastPoint.time) {
        timelinePerSecond[
          currentTimelineIndex === -1 ? 0 : currentTimelineIndex
        ] = newPoint;
      } else {
        timelinePerSecond.push(newPoint);
      }
      pendingDrops.push({ metrics: scaledMetrics, time: endTime });
    });
    attemptToRemovePendingDrops(false);

    const statisticsCount = this.statistics.length;
    const totals: Metrics & { concurrency?: number } = { ...rawTotals };
    delete totals.concurrency;

    // eslint-disable-next-line functional/no-let
    let graphArea = createEmptyComposite();
    // eslint-disable-next-line functional/no-let
    let activeDuration = 0;
    // eslint-disable-next-line @typescript-eslint/init-declarations, functional/no-let
    let lastPoint: (typeof timelinePerSecond)[number] | undefined;
    timelinePerSecond.forEach((point) => {
      if (lastPoint !== undefined && lastPoint.metrics.concurrency > 0) {
        const duration = point.time - lastPoint.time;
        graphArea = increaseMetrics(
          graphArea,
          multiplyMetric(lastPoint.metrics, duration)
        );
        activeDuration += duration;
      }
      lastPoint = point;
    });

    const average = {
      concurrency:
        activeDuration === 0 ? 0 : graphArea.concurrency / activeDuration,
      duration: statisticsCount === 0 ? 0 : sumDuration / statisticsCount,
      perActiveSecond: Object.entries(graphArea).reduce(
        (all, [key, value]) =>
          key === 'concurrency'
            ? all
            : {
                ...all,
                [key]: activeDuration === 0 ? 0 : value / activeDuration,
              },
        this.createEmptyMetrics()
      ),
    };

    return {
      activeDuration,
      average,
      statisticsCount,
      timeline: timelinePerSecond,
      totals,
    };
  }
}
